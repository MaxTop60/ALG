## 1. Архитектура Microsoft .NET Framework  
Microsoft .NET Framework- программная платформа от microsoft, предназначенная для разработки приложений преимущественно под windows.  
Ключевые компоненты:  
1. CLR (Common Language Runtime)- среда выполнения программ.  
2. BCL и FCL - базовая и расширенная бибилотеки классов (например, System, system.io, system.text в BCL и дополнительные в FCL)  
3. CTS (Common language types system)- система типов, описывающая какими должны быть типы данных, чтобы быть совместимыми с .NET  
4. CLS (Common lamguage specification)- набор правил, которые должны соблюдать языки, чтобы быть совместимыми с .NET  
5. MSIL- промежуточный язык майкрософт, в который компилируются языки .NET  
6. JIT- компилятор, переводящий MSIL в машинный код


## 2. История развития технологий программирования Windows-приложений  
Первый Windows (Windows 1.0) появился в конце 1985 года  
1. Windows API (начало 1990-ых)- низкоуровневая система для разработки оконных windows приложений на C/C++, требовала ручного управления ресурсами и событийной моделью  
2. MFC (Microsoft Foundation Classes, 1990-ые)- библиотека C++ оберток над WinAPI, упрощающая работу с окнами и элементами управления (он делает разработку высокоуровневой с использованием ООП)  
3. COM (Component Object Model, 1993)- технология компонентной модели. Позволила создавать повторно испольщуемые компоненты. Применялась в ActiveX, OLE и автоматизации приложений Office. (OLE- позволяет встраивать один документ в другой, а ActiveX- создавать любые компоненты и встривать их куда угодно, например графический интерфейс)  
4. Visual Basic (90-ые - 2000-ые)- визуальная среда для RAD разработки. Включает в себя язык программирования, среду разработки (IDE) и набор инструментов для создания приложений.  
5. .NET Framework (с 2002 года)- ввел CLR, сборку мусора, безопасное ууправление памятью, кросс-языковую солвместимость. Основной язык- C#  
6. WinForms- первая визуальная библиотека .NET для разработки GUI. Ограниченная гибкость, устаревающий дизайн.  
7. WPF (2006)- новая модель UI, основанная на XAML и привязке даных. Соверменные и натсраиваемые интерфейсы с поддержкой графики, анимации, шаблонов.  
8. UMP (2015)- единый подход к созданию приложений для Windows. Основана на WinRT. Поддерживает XAML, MVVM, магазин приложений.  
9. .Net Core / .NET 5+ (с 2016)- кроссплатформенная эволюция .NET Framework. Поддерживает windows, linux, macOS. Объединяет в себе все технологии.  
10. MAUI (2022)- развитие Xamirin.Forms (устаревающий фреймворк microsoft для разработки мобилдьных и десктопныз приложений на C# + XAML). Позволяет создавать кроссплатформенные GUI-приложения с одним C# и XAML кодом для Windows, Android, IOS, macOS.


## 3. Обобщенная структура .NET Framework  
Хз, навреное можно частично сказать то же самое, что и в первом вопросе, но вот схема структуры:  
[язык программирования] -> [компилятор в промежуточный язык]  -> [сборка в exe или dll файл] -> [исполнение в CLR] -> [JIT-компиляция в машинный код] -> [выполнение с доступом к FCL].


## 4. Основные понятия, механизмы и соглашения технологии .NET  
Основные понятия:  
1. ClR- исполняющая среда  
2. IL (intermediate language)- промеждуточный байт-код  
3. Assembley (сборка)- единица развертывания (то, что запускается). Содержит в себе IL и метаданные  
4. Namespace- пространство имен, логическая группировка классов  
5. BCL и FCL- базовая и расширенная библиотеки классов  
6. CTS и CLS- спецификации типов и языков  
7. GC- сборщик мусора, совобождающий неиспользуемую память  
Механизмы в .NET:  
1. Управляемый код- код под управлением CLR  
2. JIT-компиляция- динамическая компиляция IL в машинный код при запуске  
3. Сборка мусора- автоматическое управление памятью  
4. Рефлексия- доступ к информации о типах и сборках во время выполнения  
5. Безопасность типов- строгая проверка соответствия типов во время компиляции и исоплнения  
6. Exception handling- отлавливание ошибок через try-catch-funally  
Соглашения в .NET:  
1. Именование типов и членов- PascalCase для классов и методов и camelCase дял переменных  
2. Формат пространства имен- пример: CompanyName.TechnologyName.ModuleName  
3. Названия интерфейсов всегда пишутся с префиксом I  
4. Для именвоания событий используется глагоол в прошедшем времени  
5. Исключения должны быть унаследованы от System.Exception  
6. Используется обхявление свойств (через get и set), а не полей


## 5. Особенности выполнения .NET-приложений  
* Приложение не запускается напрямую на процессора, а исполняется через  CLR, так процесс выполнения программы становится более контроллируемым: сборка мусора, отслеживание типов, обработка исключений централизованной  
* JIT-компиляция- сначала код на языке программирования компилируется в промежуточный язык, из которого собирается в исполняемый файл, при запуске которого в реалтайме с помощью JIT компилятора переводится в машинный код.  
* Все .NET программы сначала компилируются в IL+метаданные. Метаданные содержат информацию о классах, методах, типах.  
* Есть автоматический сборщик мусора  
* CLR следит за беопасностью исполнения программы  
* Исключения представляются как объекты, котоыре можно отлавливать во время выполнения программы через try-catch-finally  
* Благодаря поэтапной компиляции, CTS и CLS есть поддержка нескольких языков программирования.


## 6.Основы языка C#  
C# - основной язык системы .NET  
Основные черты C#:  
1. Строгая типизация  
2. Объектно-ориентированность  
3. Автоматическое управление памятью  
4. Поддержка событий, делегатов, лямбда-выражений  
Базовые элементы языка:  
* Типы данных (бывают ссылочные и значимые): int, float, double, bool. char, string, decimal.  
* Операторы: арифметические +,-,*,/, логические &, &&, |, ||, !, сравнения ==, !=, <, >, присваивания =, +=, -= и т.д.  
* Условные конструкции: if, else if, else, switch, тернарные выражения  
* Циклы: for, while, do-while, foreach  
У программы есть точка входа- метод main у класса program.


## 7. Основные сведения о системе типов .NET  
Все типы в .NET происходят от базового типа System.Object  
Классификация типов в .NET:  
1. Значимые типы:  
* Наследуются от System.ValueType  
* Хранятся в стеке  
* int, float, bool, char, struct, enum  
2. Ссылочные:  
* Хранятся в куче, переменная содержит только ссылку на объект в памяти  
* Наследуются от System.Object  
* class, interface, delegate, string, object, массивы  
3. Указательные типы:  
* Позволяет напрямую работать с адресами памяти: int* ptr; //указатель на int  
Boxing и Unboxing:  
Boxing - преобразование значения типа (value type) в ссылку на объект.  
int i = 42;  
object o = i; // упаковка  
Unboxing - обратное преобразование.  
int j = (int)o; // распаковка


## 8. Компоновочные блоки, пространства имен, типы  
Компоновочный блок- основной блока рзавертывания и компоновки программ в .NET. Он представляет собой файл или группу файлов, содержащий скомиплированный код, ерсурсы, метаданные.  
Виды компоновочных блоков:  
* EXE - исполняемый файл  
* DLL - библиотека, не может быть запущена напрямую, но подключается к другим приложениям.  
Сборка состояит из промежуточного кода, метаданных, манифеста (сведений о сборке), ресурсов.  
Сборки бывают частные (используются только одним приложением) или общие (могут использоваться разными рпиложениями)

Пространство имен- логическая группировка классов, структур, интерфейсов и других типов для организации кода и предотвращения конфликтов.  
Синтаксис:  
namespace BlaBla {  
    ...blablabla...  
}  
Использование:  
using BlaBla;  
blalbalba Bob = new blablabla();

Типы  
Описывались выше  
Так же есть специальные типы, например var, auto, dynamic, nullable,  void


## 9. Спецификаторы доступа типов и членов типов  
* public	Доступен отовсюду - из любого класса, сборки и проекта.  
* private	Доступен только внутри того же класса или структуры.  
* protected	Доступен в том же классе и в его производных (наследниках).  
* internal	Доступен только в пределах той же сборки (проекта).  
* protected internal	Доступен в той же сборке и в производных классах за её пределами.  
* private protected	Доступен только в текущей сборке и только в производных классах.


## 10. Объявление и инициализация переменных и констант в C#  
Переменная- именованная область памяти.  
Объявление (выделение памяти):  
int x;  
string name;  
Инициализация (присваивание начального значения):  
int x = 10;  
string name = "Алексей";  
Комбинированное объявление:  
int a = 5, b = 10, c = 15;

Константа- неизменяемая переменная.  
Объявление:  
const double Pi = 3.14159;  
const int MaxValue = 100;  
С помощью readonly можно задать константу, значение которой будет установлено позже:  
readonly int startTime;

public MyClass() {  
    startTime = Environment.TickCount;  
}


## 11. Консольный ввод-вывод в C#  
Для этого используется класс System.Console, который предоставляет методы и свойства для чтения и записи данных в/из консоли.  
* Вывод:  
Основные методы:  
Console.Write()- вывод без перевода строки  
Console.WriteLine()- вывод с переводом строки  
Console.WriteLine(format, args...)- форматированный вывод  
Console.Write("Введите имя: ");  
Console.WriteLine("Привет, мир!");  
Console.WriteLine("Сумма: {0}", 5 + 3); // форматированный вывод  
* Ввод:  
Console.ReadLine()= считывает строку до нажатия Enter  
Console.Write("Введите ваше имя: ");  
string name = Console.ReadLine();  
Console.WriteLine($"Привет, {name}!");  
* Преобразование типов (парсинг):  
ReadLine() всегда возвращает строку, поэтому для работы с числами используется парсинг:  
Console.Write("Введите возраст: ");  
string input = Console.ReadLine();  
int age = int.Parse(input); // может вызвать исключение при ошибке  
* Специальные возможности:  
Console.ReadKey() - считывает один символ с клавиатуры без нажатия Enter  
Console.Clear() - очищает экран  
Console.ForegroundColor / BackgroundColor - управление цветом


## 12. Управление потоком выполнения в программе. Условный оператор. Оператор выбора.  
Управление потоком выполнения в программе- способность программы принимать реiения и выполнять разные действияв зависимости от условий.  
Условный оператор- if..else  
if (условие) {  
    //код если true  
} else {  
    //код если false  
}  
Тернарный оператор:  
условие ? если true : если false;  
Оператор выбора switch:  
switch (day) {  
    case 1:  
        Console.WriteLine("Понедельник");  
        break;  
    case 2:  
        Console.WriteLine("Вторник");  
        break;  
    default:  
        Console.WriteLine("Неизвестный день");  
        break;  
}  
Так же в новых версиях C# switch можно использовать вместе с when:  
switch (x) {  
    case int n when n > 0:  
        Console.WriteLine("Положительное");  
        break;  
}


## 13. Управление потоком выполнения в программе. Оператор цикла for.  
Цикл for используется  для повторного выполнения блока кода определенное количество раз.  
for (инициализация; условие; итерация) {  
    // Тело цикла  
}  
С помощью break и continue можно управлять поведением цикла.


## 14. Управление потоком выполнения в программе. Цикл с предусловием while. Цикл с постусловием do..while  
Эти циклы выполняются пока условие переданное им истинно.  
While- сначала проверяется условие, а потом происходит итерация.  
do .. while- сначала делается итерация, а потом проверяется условие (делать ли следующую итерацию).  
С помощью break и continue можно управлять поведением цикла.


## 15. Массивы. Простые массивы  
Массив- структура данных, содержащая в себе фиксированное количество элементов одного типа, размещенных подряд в памяти.  
Объявление:  
int[] x numbers;  
Выделение памяти:  
numbers = new int[5];  
Инициализация:  
int numbers = {1,2,3,4,5};  
Доступ к элементам массива осуществляется по индексу (отсчет с 0):  
Console.WriteLine(numbers[0]); //Выводит 1  
Можно перебирать с помощью foreach:  
foreach (int n in numbers) {  
    Console.WriteLine(n); // 1 2 3 4 5  
}


## 16. Многомерные массивы  
Многомерные массивы- массивы с более чем одним измерением (с другими вложенными массивами одинаковой размерности).

int[,] matrix = new int[3, 2]; // 3 строки, 2 столбца

Инициализация:  
int[,] matrix = {  
    {1, 2},  
    {3, 4},  
    {5, 6}  
};

Доступ к элементам:  
Console.WriteLine(matrix[0, 1]); // 2  
matrix[2, 0] = 10;               // замена элемента (3-я строка, 1-й столбец)


## 17. Зубчатые массивы  
Зубчатый массив- массив из массивов допустимо разной длины.  
int[][] jagged = new int[3][]; // массив из 3 массивов  
Инициализация вложенных массивов:  
jagged[0] = new int[] { 1, 2 };  
jagged[1] = new int[] { 3, 4, 5 };  
jagged[2] = new int[] { 6 };  
//или  
int[][] jagged = {  
    new int[] { 1, 2 },  
    new int[] { 3, 4, 5 },  
    new int[] { 6 }  
};  
Доступ к элементам:  
int x = jagged[1][2]; // 5 - 3-й элемент во 2-й строке  
jagged[2][0] = 10;    // изменяет значение 6 на 10


## 18. Класс Array  
Array- базовый класс дял всех массивов в C#. Предоставляет универсальные методы и свойства для работы с массивами.  
Создание:  
Array arr = Array.CreateInstance(typeof(int), 5);  
arr.SetValue(10, 0);  
Console.WriteLine(arr.GetValue(0)); // 10  
Полезные методы класса Array:  
| Метод                              | Назначение                           |  
| ---------------------------------- | ------------------------------------ |  
| `Array.Sort(array)`                | Сортирует массив по возрастанию      |  
| `Array.Reverse(array)`             | Меняет порядок элементов на обратный |  
| `Array.IndexOf(array, value)`      | Возвращает индекс первого вхождения  |  
| `Array.LastIndexOf(array, value)`  | Индекс последнего вхождения          |  
| `Array.Copy(src, dst, length)`     | Копирует элементы                    |  
| `Array.Clear(array, start, count)` | Обнуляет элементы                    |  
Полезные свойства:  
Length- длина  
Rank- ранг (количество измерений)  
GetLength(dimension) - длина по указанному измерению.


## 19. Основы объектно-ориентированного программирования. Классы и структуры  
ООП- парадигма праграммирования, основанная на представлении программы в виде объектов, каждый из которых является экземпляром класса или структуры.  
Основные принципы ООП:  
Инкапсуляция- объединение данных и методов в одном объекте, сокрытие реализации.  
Наследование- возможность создавать новые класс на основе существующих.  
Полиморфизм- возможно единообразно обращаться к объектам разных типов.  
Абстракция- выделение только значимых характеристик объекта  
Классы в C#- это ссылочный тип, хранящийся в куче. Классы могут иметь конструкторы, методы, свойства, союытия и т.д.  
Структуры в C#- это значимый тип, хранящийся в стеке. Имеет обязательную инициализацию. Не поддерживает наследования.


## 20. Данные-члены класса. Функции-члены класса  
В C# классы состоят из членов класса- переменных, методов, свойств и других конструкций, описывающих поведение и состояние объектов.  
* Данные-члены класса- это поля. Поля- переменные, определенные внутри класса и хранящие состояние объекта.  
* Функции-члены класса- это методы. Методы- функции, определенные внутри класса, описывающие действия объекта. Методы можно перегружать с разными параметрами.  
* Конструктор- особый метод, исопльзуемый для ирнициализации объекта:  
class Person {  
    public string Name;  
    public Person(string name) {  
        Name = name;  
    }  
}  
* Свойства используются для обеспечения и контроля доступа к полям:  
private int age;  
public int Age {  
    get { return age; }  
    set { age = value; }  
}


## 21. Методы классов. Конструкторы. Перегрузка методов  
* Метод- функция, определенная внутри класса, реализующая какой-то его функционал.  
* Конуструктор- специальный метод, выхываемыый при создании объекта. Его задача- инициализировать объект.  
Синтаксис:  
class MyClass {  
    public int x;  
      
    public MyClass(int value) {  
        x = value;  
    }  
}  
Конструктор по умолчанию создается атоматически, если в классе нет других конструкторов.  
Статический конструктор вызывается один раз для класса перед первым его использования (например, создания объекта или вызова статического челна). Не имеет параметров и не вызывается вручную.  
Приватные конструктор создают для запрета на создание объектов класса извне.  
* Перегрузка методов позволяет создавать в одном классе несколько методов с одним именем, но разными параметрами.  
Пример:  
class Calculator {  
    public int Add(int a, int b) => a + b;  
    public double Add(double a, double b) => a + b;  
}


## 22. Операции. Перегрузка операций  
Перегрузка операций- возможность определить, как стандартные операторы работают с объектами пользовательских классов.  
Синтаксис перегрузки:  
public static тип_результата operator оператор(тип 1 a, тип 2 b) {  
    // реализация  
}  
Какие операторы можно перегрузить:  
| Группа               | Примеры                          |         |  
| -------------------- | -------------------------------- | ------- |  
| Арифметические       | `+`, `-`, `*`, `/`, `%`          |         |  
| Унарные              | `+`, `-`, `!`, `~`, `++`, `--`   |         |  
| Логические           | `true`, `false`, `&`, \`         | `, `^\` |  
| Сравнения            | `==`, `!=`, `<`, `>`, `<=`, `>=` |         |  
| Преобразования типов | `explicit`, `implicit`           |         |  
Какие операторы нельзя перегрузить:  
* =, . (точка), ?:, [], ->, new, typeof, is, as


## 23. Наследование в объектно-ориентированном программировании. Полиморфизм  
Наследование- механизм ООП, позволяющий одному классу(дочернего) использовать свойства и методы другого класса(родительского).  
Чтобы показать, что данный класс наследуется от другого, мы указываем после гео названия через двоеточие родительский класс.  
Пример:  
class Animal {  
    public void Speak() {  
        Console.WriteLine("Животное издает звук");  
    }  
}

class Dog : Animal {  
    public void Bark() {  
        Console.WriteLine("Собака лает");  
    }  
}  
Полиморфизм- возможность обращаться к объектам разных классов через общий интерфейс или базовый класс, вызывая разные реализации одного и того же метода.  
Способы реализации полиморфизма:  
1. Через модификаторы virtual + override  
2. Через interface  
3. С помощью перегрзуки методов  
| Ключевое слово | Назначение                                            |  
| -------------- | ----------------------------------------------------- |  
| `virtual`      | Объявляет метод в базовом классе как переопределяемый |  
| `override`     | Переопределяет `virtual`-метод в производном классе   |  
| `new`          | Скрывает метод базового класса (не полиморфизм!)      |  
| `base`         | Ссылка на базовый класс внутри наследника             |


## 24. Наследование реализации  
Наследование реализации- ситуация, когда дочерний класс получает реализацию методов и свойств от базового класса, без необходимости повторно описывать код.  
Пример:  
class Vehicle {  
    public void StartEngine() {  
        Console.WriteLine("Двигатель запущен");  
    }  
}

class Car : Vehicle {  
    // Наследует StartEngine без изменений  
}


## 25. Наследование интерфейсов  
Интерфейс- набор объявлений методов, свойств, соббытий или индексов без реализации. Класс, реализующий интерфейс обязан реализовать все его члены.  
Принято давать интерфейсам названия, начинающиеся с I.  
interface IMovable {  
    void Move();  
}  
Наследование интерфейсов- это когда класс может реализовывать один или несколько нтерфейсов, что позволяет ему гарантировать наличие определенного поведения. Разрешен о множественное наследование интерфейсов.  
Интерфейс может наследовать другие интерфейсы:  
interface ITransport {  
    void Start();  
}

interface IFlyable : ITransport {  
    void Fly();  
}

class Plane : IFlyable {  
    public void Start() => Console.WriteLine("Запуск");  
    public void Fly() => Console.WriteLine("Летим");  
}


## 26. Коллекции в .NET Framework  
Коллекции- это контейнеры для хранения групп объектов.  
.NET Framework предоставляет множество коллекций в пространстве имен System.Collections, System.Collections.Generic, System.Collections.Concurrent и др.  
1. Негенрические коллекции (System.Collections)  
* ArrayList- инамический массив объектов  
* Hashtable- коллекция пар ключ/значение  
* Queue- очередь  
* Stack- стек  
* Работают с object, из-за чего требуют преобразования типов (boxing/unboxing)  
2. Генерические коллекции (System.Collections.Generic)  
* Работают с типами данных, указанными в <T>, что повышает безопасность и производительность.  
* List<T>- список  
* Dictionary<Tkey, Tvalue>- словарь  
* Queue<T>, Stack<T>  
* LinkedList<T>, SortedList<Tkey, Tvalue>, HashSet<T>  
3. Специальные коллекции (System.Collections.Specialized)  
* NameValueCollection  
* StringCollection  
* BitVector32  
* Используются в специфических случаях.  
4. Параллельные коллекции (System.Collections.Concurrent)  
* Для многопоточных приложний, потокобезопасные  
* ConcurrentQueue<T>  
* ConcurrentDictionary<Tkey, Tvalue>  
* BlockingCollection<T>  
* Полезны чтобы при возникновении гонок потоков (сорвенований за критические данные) программа сохраняла работоспособность


## 27. Интерфейсы и типы коллекций  
В .NET коллекции реализуют стандартизированыне интерфейсы, что позволяет:  
* Работать с ними унифицированно  
* Использовать обобщенные методы  
* Подменять одну реализацию на другую без изменения кода  
Основные интерфейсы коллекций:  
* IEnumerable и IEnumerator  
+ Базовые интерфейсы для перебора коллекций с помощью foreach  
* ICollection  
+ Добавляет Count, Add, Remove, Clear, Contains, IsReadOnly  
* IList  
+ Добавляет доступ к элементам по индексу  
+ Наследует от ICollection  
Обобщенные интерфейсы:  
| Интерфейс                  | Назначение                                 |  
| -------------------------- | ------------------------------------------ |  
| `IEnumerable<T>`           | Перебор с типобезопасностью (`foreach`)    |  
| `ICollection<T>`           | Работа с элементами (добавление, удаление) |  
| `IList<T>`                 | Индексация + вставка/удаление по индексу   |  
| `IDictionary<TKey,TValue>` | Работа с парами "ключ-значение"            |  
| `ISet<T>`                  | Множества, поддержка уникальности          |  
| `IReadOnlyCollection<T>`   | Только чтение (`Count`, `foreach`)         |  
| `IReadOnlyList<T>`         | Только чтение + доступ по индексу          |


## 28. Списки  
List<T>- список- динамический массив из пространства имен System.Collections.Generic. Автоматически расширяется, когда в него добавляют новые элементы.  
Основные возможности:  
List<int> numbers = new List<int>();  
numbers.Add(1);  
numbers.AddRange(new[] { 2, 3, 4 });  
numbers.Remove(2);  
numbers.Insert(1, 100);  
Перебор элементов:foreach (int n in numbers) {  
    Console.WriteLine(n);  
}  
Важные методы и свойства:  
| Метод / Свойство      | Описание                          |  
| --------------------- | --------------------------------- |  
| `Add(item)`           | Добавить элемент                  |  
| `AddRange(items)`     | Добавить сразу несколько          |  
| `Insert(index, item)` | Вставить по индексу               |  
| `Remove(item)`        | Удалить первое вхождение          |  
| `RemoveAt(index)`     | Удалить по индексу                |  
| `Contains(item)`      | Проверить наличие                 |  
| `IndexOf(item)`       | Индекс первого вхождения          |  
| `Clear()`             | Очистить список                   |  
| `Count`               | Кол-во элементов                  |  
| `Capacity`            | Текущий объём внутреннего массива |  
| `Sort()`, `Reverse()` | Сортировка и разворот             |  
Как работает:  
* Внутри используется обычный массив  
* При переполнении- создается новый массив большего размера, и элементы копируются.  
Когда использовать:  
✅ Когда тебе нужен быстрый доступ по индексу  
✅ Когда ты часто добавляешь элементы в конец  
❌ Неэффективен при частом добавлении/удалении в середине или начале списка (лучше LinkedList<T>)


## 29. Очередь  
Queue<T>- очередь- коллекция из пространства имен System/Collections.Generic, реализующая структуру, работающую по принципу "первый зашел- первый вышел".  
Как работает:  
* Элементы добавляются в конец, а извлекаются из начала.  
Основные методы:  
| Метод           | Назначение                                   |  
| --------------- | -------------------------------------------- |  
| `Enqueue(item)` | Добавляет элемент в конец очереди            |  
| `Dequeue()`     | Удаляет и возвращает элемент с начала        |  
| `Peek()`        | Возвращает элемент с начала **без удаления** |  
| `Count`         | Возвращает количество элементов в очереди    |


## 30. Стек  
Stack<T>- коллекция из пространства имен System.Collections.Generic, работающую по принципу "последний зашел- первый вышел".  
Основные методы:  
| Метод        | Описание                                    |  
| ------------ | ------------------------------------------- |  
| `Push(item)` | Помещает элемент **на вершину стека**       |  
| `Pop()`      | Удаляет и возвращает верхний элемент        |  
| `Peek()`     | Возвращает верхний элемент **без удаления** |  
| `Count`      | Возвращает количество элементов в стеке     |  
| `Clear()`    | Очищает стек                                |


## 31. Взаимодействие с файловой системой  
В .NET для работы с файловой системой исползуется пространство имен System.IO.  
Основные классы для работы с файловой системой:  
| Класс           | Назначение                                  |  
| --------------- | ------------------------------------------- |  
| `File`          | Работа с файлами (быстрая и простая)        |  
| `FileInfo`      | Расширенная работа с файлами (через объект) |  
| `Directory`     | Работа с папками                            |  
| `DirectoryInfo` | Работа с папками как с объектами            |  
| `Path`          | Работа с путями                             |  
| `DriveInfo`     | Информация о дисках                         |  
Что можно сделать с помощью System.IO:  
| Действие                       | Как сделать                 |  
| ------------------------------ | --------------------------- |  
| Проверить существование файла  | `File.Exists(path)`         |  
| Удалить файл                   | `File.Delete(path)`         |  
| Копировать файл                | `File.Copy(src, dst)`       |  
| Переместить файл               | `File.Move(src, dst)`       |  
| Получить расширение            | `Path.GetExtension(path)`   |  
| Получить имя файла без пути    | `Path.GetFileName(path)`    |  
| Получить список файлов в папке | `Directory.GetFiles(path)`  |  
| Узнать размер файла            | `new FileInfo(path).Length` |


## 32. Классы .NET Framework для реаллизации операций ввода-вывод  
Работа с операциями ввода-вывода в .NET осуществляется с помощью пространства имен System.IO.  
Основыне классы ввода-вывода:  
| Класс               | Назначение                                         |  
| ------------------- | -------------------------------------------------- |  
| `FileStream`        | Побайтовая работа с файлами и потоками             |  
| `StreamReader`      | Чтение текста из потока                            |  
| `StreamWriter`      | Запись текста в поток                              |  
| `BinaryReader`      | Чтение бинарных данных                             |  
| `BinaryWriter`      | Запись бинарных данных                             |  
| `MemoryStream`      | Работа с данными в оперативной памяти              |  
| `BufferedStream`    | Буферизация потоков                                |  
| `File` / `FileInfo` | Простые статические и объектные операции с файлами |  
Поток- абстракция источника или получателя данных, которая позволяет последовательно читать или записывать байты.


## 33. Классы для работы с каталогами файловой системы  
Их предоставляет пространство имен System.IO  
Основные классы:  
* Directory  
+ Статический класс  
+ Позволяет работать с каталогами без создания объектов  
+ Примеры:  
Directory.CreateDirectory("Logs");  
bool exists = Directory.Exists("Logs");  
string[] files = Directory.GetFiles("Logs");  
Directory.Delete("Logs", recursive: true);  
* DirectoryInfo  
+ Объектный аналог Directory  
+ Подходит для работы с одним конкретным каталогом  
+ Пример:  
DirectoryInfo dir = new DirectoryInfo("Logs");

if (!dir.Exists)  
    dir.Create();

FileInfo[] files = dir.GetFiles();  
DirectoryInfo[] subdirs = dir.GetDirectories();

| Операция                         | `Directory`                                        | `DirectoryInfo`     |  
| -------------------------------- | -------------------------------------------------- | ------------------- |  
| Создание каталога                | `CreateDirectory(path)`                            | `Create()`          |  
| Удаление каталога                | `Delete(path)`                                     | `Delete()`          |  
| Проверка существования           | `Exists(path)`                                     | `Exists` (свойство) |  
| Получение файлов                 | `GetFiles(path)`                                   | `GetFiles()`        |  
| Получение подкаталогов           | `GetDirectories(path)`                             | `GetDirectories()`  |  
| Получение всех файлов рекурсивно | `GetFiles(path, "*", SearchOption.AllDirectories)` | аналогично          |


## 34. Классы для работы с файлами  
Их так же предоставляет пространство имен System.IO  
Основные классы:  
* File  
+ Статический класс для простых операций  
+ Позволяет создавать, копировать, удалять, читать и записывать файлы  
+ Примеры:  
File.WriteAllText("file.txt", "Привет");  
string text = File.ReadAllText("file.txt");  
File.Delete("file.txt");  
* FileInfo  
+ Объектный аналог File  
+ Удобен при работе с одним файлом и доступом к его свойствам  
+ Пример:  
FileInfo fi = new FileInfo("file.txt");

if (fi.Exists) {  
    Console.WriteLine($"Размер: {fi.Length}");  
    fi.CopyTo("copy.txt");  
    fi.Delete();  
}

| Возможность              | Класс `File`                    | Класс `FileInfo`                            |  
| ------------------------ | ------------------------------- | ------------------------------------------- |  
| Чтение/запись текста     | `ReadAllText`, `WriteAllText`   | через `StreamWriter` и `StreamReader`       |  
| Копирование, удаление    | `Copy`, `Delete`                | `CopyTo`, `Delete`                          |  
| Проверка существования   | `Exists(path)`                  | `Exists` (свойство)                         |  
| Работа с байтами         | `ReadAllBytes`, `WriteAllBytes` | тоже можно через `FileStream`               |  
| Получение метаинформации | -                               | `Length`, `CreationTime`, `Extension` и др. |


## 35. Потоки в системе ввода-вывода  
Поток в контексте ввода-вывода- последовательный канал передачи данных межуд источником и получаетелем.  
Базовый класс для всех потоков: System.IO.Stream. От него наследуются:  
* FileStream- чтение/запись файлов  
* MemoryStream- работа с памяятью как с потоком  
* NettworkStream- передача по сети  
* BufferedStream- буферизация других потоков  
Буфер = временное хранилище.  
Ключевые члены Stream:  
| Член       | Назначение                        |  
| ---------- | --------------------------------- |  
| `Read()`   | Читает байты                      |  
| `Write()`  | Записывает байты                  |  
| `Seek()`   | Перемещает позицию в потоке       |  
| `Flush()`  | Сбрасывает буфер в конечный поток |  
| `Position` | Текущая позиция                   |  
| `Length`   | Общая длина потока                |  
Текстовые потоки (обертки над байтовыми потоками):  
* StreamReader- читает текст из потока  
* StreamWriter- пишет текст в поток


## 36. Байтовый поток  
Байтовый поток- механизм ввода-вывода, работающий с последовательностями байтов. Он используется для чтения и записи двоичных данных, то есть не текстовой информации, а, например, изображений, файлов и других типов данных.  
Базовый класс для всех байтовых потоков: System.IO.Stream  
Производные классы:  
* FileStream- используестся для чтения и записи файлов  
* MempryStream- использует оперативную память как поток  
* BufferedStream- обертка для других потоков, добавляющая буферизацию  
Особенности FileStream:  
* Работает с массивом байтов  
* Можно задавать режимы доступа: Read, Write, ReadWrite  
* Часто используется совместно с BinaryReader и BinaryWriter


## 37. Символьный поток  
Символьный поток- поток ввода-вывода, предназначенный для работы с текстовой информацией, то есть с последовательностью символов, а не байтов. Такие потоки автоматически используют кодировку для преобразования между байтами и символами.  
Основные классы:  
* StreamReader- для чтения текста из потока.  
* StreanWriter- для записи текста в поток.  
Они использую базовый класс Stream, но при этом работают с текстом, а не байтами.  
Пример:  
using (StreamWriter writer = new StreamWriter("text.txt"))  
{  
    writer.WriteLine("Привет, мир!");  
    writer.WriteLine("Это символьный поток.");  
}  
Flush() - вручную очищает буфер, то есть заставляет поток записать все накопленное в файл.  
С помощью using можно автоматизировать закрытие и очистку буфера:  
using (StreamWriter writer = new StreamWriter("file.txt"))  
{  
    writer.Write("данные");  
} // здесь автоматически вызывается Flush() и Close()


## 38. Делегаты, события и лямбда-выражения  
Делегат- тип данных, хранящий ссылку на метод/методы с определенной сигнатурой. Бывают делегаты одиночного вызова и групповые.  
Объявление:  
delegate тип_данных название(параметры);  
Использование:  
delegate void MyDelegate(string message);

void Print(string msg) => Console.WriteLine(msg);

MyDelegate d = Print;  
d("Привет!");

Событие- механизм, позволяющий другим частям программы полписаться на событие, чтобы быть уведомленными, когда что-то произойдет.  
События основаны на делегатах, но можно только добавлять или удалять обработчики, их может вызывать только владелец события.

Лямбда-выражения- краткая форма записи анонимного метода. Пример:  
Action<string> printer = text => Console.WriteLine(text);  
printer("Привет от лямбды!");


## 39. Делегаты  
Рассмотрено выше


## 40. Делегаты Action<T> и Func<T> библиотеки .NET Framework  
Action и Func это встроенные обобщенные делегаты, которые позволяют не создавать свои delegate типы вручную. Они покрывают большинство случаев в современной практике.  
Action не возвращает ничего.  
Func возвращает значение последнего указанного типа.  
Примеры:  
Action hello = () => Console.WriteLine("Привет");  
hello();

Action<int> print = x => Console.WriteLine($"x = {x}");  
print(42);

Action<int, int> sum = (a, b) => Console.WriteLine(a + b);  
sum(2, 3); // 5

Func<int> getFive = () => 5;  
Console.WriteLine(getFive()); // 5

Func<int, int> square = x => x * x;  
Console.WriteLine(square(4)); // 16

Func<int, int, int> add = (a, b) => a + b;  
Console.WriteLine(add(2, 3)); // 5

Это удобнее ручных делегатов потому что экономит время и код.  
Сравнение:  
❌ Без Func:  
delegate int BinaryOp(int a, int b);  
BinaryOp add = (a, b) => a + b;  
✅ С Func:  
Func<int, int, int> add = (a, b) => a + b;


## 41. Групповые делегаты  
Групповой делегат- делегат, который хранит в себе несколько методов и вызывает их всех по очереди при вызове.  
Методы добавляются в делегата с помощью оператора +=.  
Пример:  
delegate void Notify();

void A() => Console.WriteLine("Метод A");  
void B() => Console.WriteLine("Метод B");

Notify n = A;  
n += B;

n(); // вызовет A, затем B  
Как это работает:  
* Делегат содержит список методов в цепочке вызова.  
* Вызывает все методы из списка по порядку.  
* Если один из вызовов выбрасывает исключение- остальные не вызовутся (если не обернуть в try)  
Если методы, присвоеные делегату возвращают значение, то результатом будет являться выход последнего метода:  
delegate int Calc(int x);  
Calc c = x => x + 1;  
c += x => x * 2;  
int result = c(5); // ❗ результат будет только от последнего метода: 5 * 2 = 10


## 42. Анонимные методы  
Анонимный метод- метод без имени, который можно создать прямо внутри кода, обычно для передачи в делегат.  
Он появился до лямбда-выражений и выглядит так:  
delegate void MyDelegate(string msg);  
MyDelegate dlg = delegate (string msg) {  
    Console.WriteLine(msg);  
}  
Используется чтобы не создавать отдельный именованный метод, когда он нужен один раз.  
В отличие от лямбда-выражений поддерживает goto, break, continue;


## 43. Лямбда выражения  
Лямбда выражение- анонимная функция, которую можно присвоить делегату или использовать прямо в коде.  
Синтаксис:  
(параметры) => { тело }  
Если тело- одна строка, то скобки и return можно опустить:  
x => x * x  
Варианты записи:  
| Назначение           | Пример                          |  
| -------------------- | ------------------------------- |  
| Без параметров       | `() => Console.WriteLine("Hi")` |  
| Один параметр        | `x => x + 1`                    |  
| Несколько параметров | `(x, y) => x + y`               |  
| С фигурными скобками | `x => { return x * x; }`        |  
Лямбда-функция- компактный способ записи функций, однако он не поддерживает break, continue, goto.


## 44. События  
Событие- специальный механизм в C#, построенный на делегатах, который позволяет объектам уведомлять других о том, что что-то произошло.  
Основная идея:  
* Событие объявляется внутри класса  
* Внешние объекты могут подписываться на это событие или отписываться от него (через += и -=)  
* Но вызывать событие может только сам класс, внутри себя  
Синтаксис:  
* Объявление делегата и события:  
public delegate void DamageHandler(int damage);  
public event DamageHandler OnDamaged;  
//или сразу встроенный тип делегата:  
public event Action<int> OnDamaged;  
* Вызов события внутри класса:  
OnDamaged?.Invoke(10);  
* Подписка на событие:  
myObject.OnDamaged += amount => Console.WriteLine($"Урон: {amount}");


## 45. Язык интегрированных запросов  
LINQ- это технология в .NET, которая позволяет писать запросы к коллекциям, базам данных, XML, файлам и т.п. прямо в коде C#, используя единый, понятный синтаксис.  
Главная идея: обрабатывать данные так же удоюно, как будето ты работаешь внутри SQL прямо вунтри C#.  
Пример LINQ запроса:  
int[] numbers = { 1, 2, 3, 4, 5, 6 };

var evens = numbers.Where(n => n % 2 == 0);

foreach (var n in evens)  
    Console.WriteLine(n); // 2, 4, 6

LINQ запросы можно писать в двух стилях:  
* Метод-стиль:  
var result = list  
    .Where(x => x > 10)  
    .Select(x => x * 2)  
    .OrderBy(x => x);  
* SQL стиль:  
var result = from x in list  
             where x > 10  
             orderby x  
             select x * 2;

Что можно делать через LINQ:  
* Where- фильтрация  
* Select- проекция  
* OrderBy, ThenBy- сортировка  
* GroupBy- группировка  
* Join- объединений коллекций  
* Aggregate, Sum, Average- агрегация  
* First, Single, Any, All- выбор и проверка


## 46. Понятие языка встроенных запросов  
Язык встроенных запросов- язык, который встраивается прямо в код программировния и позволяет делать запросы к данным внутри языка, а не снаружи. В контексте .NET и C#- это LINQ (Language Integrated Query).  
Все остальное как в вопросе выше.


## 47. Расширяющие методы  
Расширяющий метод- способ добавить новые методы к уже существующим типам, не изменяя их исходный код и не наследуясь от них. На самом деле вызывается обычный статический метод, но выглядит как метод экземпляра.  
Синтаксис:  
public static class MyExtensions  
{  
    public static int Double(this int x)  
    {  
        return x * 2;  
    }  
}  
int a = 5;  
Console.WriteLine(a.Double()); // 10  
Расширяющие методы добавляют поведение к типам .NET или чужим классам, не трогая их код, улучшают читаемость.


## 48. Стандартные операции запросов  
Стандартные операции запросов- это набор методов, предоставляемых LINQ, которые позволяют выполнять типовые действия с данными:  фильтрация, сортировка, проекция, агрегация и т.д.  
Эти методы реализованы как расширяющие методы для интерфейса IEnumerable.  
* Where- фильтрация  
* Select- проекция  
* OrderBy, ThenBy- сортировка  
* GroupBy- группировка  
* Join- объединений коллекций  
* Aggregate, Sum, Average- агрегация  
* First, Single, Any, All- выбор и проверка


## 49. Потоки, задачи, синхронизация  
* Поток- единица выполнения в рамках процесса. Потоки позволяют выполнять несколько фрагментов кода параллельно. В .NET потоки релизуются через класс System.Threading.Thread.  
Пример создания потока:  
Thread t = new Thread(() => Console.WriteLine("Вторичный поток"));  
t.Start();  
* Задача- объект, представляющий асинхронную операцию. В отличие от Thread, Task работает через пул потоков, что делает его более эффективным. Подддерживает механизм async/await.  
Пример:  
Task.Run(() => Console.WriteLine("Задача выполнена"));  
Пул потоков нужен чтобы ускорить программу, посколько создание нового потока- дорогая операция. Пул потоков- общий наьор заранее созданных потоков.  
async/await- синтаксис для асинхронного выполнения кода без блокировки потоков. async пишется в модификаторах метода и говорит, что метод может выполняться асинхронно. Await пишет перед какой-либо операцией внутри метода и говорит поставить выполнение метода на паузу и осовободить поток до тех пор, пока операция не завершится, после чего продолжить с того же места.  
* Синхронизация- механизм, обеспечивающий корректный доступ нескольких потоков к разделяемым ресурсам, предотвращающий гонки данных и ошибки. Это управление доступом к разделяемым данным, чтобы несколько потоков не мешали друг другу.  
Способы синхронизации:  
+ lock- блокировка участка кода. Остальные потоки ждут, пока lock освободится:  
object locker = new object();

lock (locker)  
{  
    // Только один поток попадёт сюда за раз  
    count++;  
}  
+ Interlocked- делает операцию атомарной (неделимой):  
Interlocked.Increment(ref count);  
+ Mutex- для межпоточной/межпроцессорной блокировки  
+ Semaphore- ограничивает количество одновременно работающих потоков  
+ Monnitor- основа lock, позволяет вручную Enter/Exit


## 50. Понятие потока  
Поток- единица выполнения кода внутри процесса.  
Каждая программа по умолчанию запускается с одним основным потоком, в котором выполняется main.  
Для параллельного выполнения задач можно создать дополнительные потоки.  
Основные характеристики потока:  
* имеет свой контекст выполнения  
* независим от других потоков  
* потоки могут выполняться параллельно на многоядерных процессорах  
* управляются через System.Threading.Thread или через Task (пул потоков)


## 51. Аснхронные делегаты  
Асинхронный делегат- это обычный делегат, вызов которого выполняется асинхронно, без блокировки выполняющего потока. Это реализуется благодарям методам BeginInvoke() и EndInvoke().  
Синтаксис:  
delegate int Calc(int x, int y);

int Add(int a, int b) => a + b;

Calc c = Add;

IAsyncResult asyncResult = c.BeginInvoke(3, 4, null, null);  
int result = c.EndInvoke(asyncResult);  
Console.WriteLine(result); // 7  
Как работает:  
* BeginInvoke(...) запускает метод в другом потоке из пула потоков  
* Метод возвращает IAsyncResult, по которому можно узнать, когда операция завершится  
* EndInvoke(...) блокирует выполнения, пока не получит результат  
Это способ является устаревшим из-за своей непрактичности и нечитабельности, поэтому используется соверменных подход, основанный на Task (однако это не делегат, так как выполняется с помощью Task и является новым асинхронным стилем):  
Func<int, int, int> add = (a, b) => a + b;  
Task<int> task = Task.Run(() => add(3, 4));  
int result = await task;


## 52. Класс Thread  
Thread- класс из пространства имен System.Threading, представляющий поток выполнения. Он позволяет запускать метож в параллельном потоке.  
Основные характеристики:  
* Позволяет вручную управлять потоком: запуска, приостановка, завершение  
* Каждому потоку выделяется отдельный стек  
* Рекомендуется использовать только при необходимости низкоуровевого управления  
Операция выделения нового потока является очень дорого, поэтом не рекомендуется делать это часто. В таком случае лучше использовать Task.  
Синтаксис:  
void Work() => Console.WriteLine("Работаю");  
Thread t = new Thread(Work);  
t.Start();  
| Свойство/метод     | Назначение                           |  
| ------------------ | ------------------------------------ |  
| `Start()`          | Запускает поток                      |  
| `IsAlive`          | Проверяет, работает ли поток         |  
| `Join()`           | Ожидает завершения потока            |  
| `Sleep(ms)`        | Приостанавливает текущий поток       |  
| `Abort()`          | (устаревший) попытка завершить поток |  
| `Name`, `Priority` | Дополнительные параметры управления  |


## 53. Передача данных потокам  
Удивительно, но передача данных потоку- это процесс передачи данных от одного потока к другому.  
Способы передачи данных:  
1. Через параметр в ParametrizedThreadStart:  
void PrintMessage(object msg)  
{  
    Console.WriteLine("Сообщение: " + msg);  
}

Thread t = new Thread(new ParameterizedThreadStart(PrintMessage));  
t.Start("Привет!"); // передаём строку  
2. Через лямбду с захватом переменной (предпотчительно, из-за компактности, отсутствия преобразований типов):  
string text = "Привет от потока";

Thread t = new Thread(() => Console.WriteLine(text));  
t.Start();  
3. Через поля или свойства объекта:  
class Worker  
{  
    public string Message;

    public void Work()  
    {  
        Console.WriteLine("Message: " + Message);  
    }  
}

var w = new Worker { Message = "Данные в объекте" };  
Thread t = new Thread(w.Work);  
t.Start();  
Для потокобезопасной передачи часто используют ConcurrentQueue, BlockingCollection, ThreadLocal, ThreadStatic.


## 54. Задачи  
* Задача- объект, представляющий асинхронную операцию. В отличие от Thread, Task работает через пул потоков, что делает его более эффективным. Подддерживает механизм async/await.  
Самый простой пример:  
Task.Run(() => Console.WriteLine("Задача выполнена"));  
Задача с результатом:  
Task<int> t = Task.Run(() => 5 + 3);  
int result = await t; // 8  
Через async метод:  
async Task<int> AddAsync()  
{  
    await Task.Delay(1000);  
    return 42;  
}  
Пул потоков нужен чтобы ускорить программу, посколько создание нового потока- дорогая операция. Пул потоков- общий наьор заранее созданных потоков.  
async/await- синтаксис для асинхронного выполнения кода без блокировки потоков. async пишется в модификаторах метода и говорит, что метод может выполняться асинхронно. Await пишет перед какой-либо операцией внутри метода и говорит поставить выполнение метода на паузу и осовободить поток до тех пор, пока операция не завершится, после чего продолжить с того же места.  
| Метод / свойство | Описание                         |  
| ---------------- | -------------------------------- |  
| `Start()`        | Запуск задачи вручную            |  
| `Wait()`         | Блокирует поток до завершения    |  
| `Result`         | Получение результата (блокирует) |  
| `IsCompleted`    | Завершена ли задача              |  
| `ContinueWith()` | Цепочка задач                    |


## 55. Таймеры  
Таймер- компонент, который автоматически вызывает заданный метод через определенные интервали времени, без необходимости вручную использовать Thread.Sleep() или while.  
Основные виды таймеров:  
| Тип                          | Пространство имён          | Подходит для                      |  
| ---------------------------- | -------------------------- | --------------------------------- |  
| `System.Timers.Timer`        | `System.Timers`            | Универсальный, многопоточный      |  
| `System.Threading.Timer`     | `System.Threading`         | Низкоуровневый, точный            |  
| `System.Windows.Forms.Timer` | `System.Windows.Forms`     | Только для WinForms, на UI-потоке |  
| `DispatcherTimer`            | `System.Windows.Threading` | Для WPF                           |  
Пример System.Timers.Timer:  
using System.Timers;

Timer timer = new Timer(1000); // интервал: 1000 мс = 1 секунда  
timer.Elapsed += (s, e) => Console.WriteLine("Тик " + DateTime.Now);  
timer.AutoReset = true;  
timer.Start();

Пример System.Threading.Timer:  
using System.Threading;

Timer t = new Timer(  
    callback: _ => Console.WriteLine("Сработал таймер"),  
    state: null,  
    dueTime: 0,         // запуск сразу  
    period: 2000        // каждые 2 секунды  
);


## 56. Итеративная инкрементальная разработка  
Итеративная инкрементальная разработка- подход, при котором проект развивается через повторяющиеся циклы (итерации), и в ходе каждого цикла добавляются нвоые функции (инкременты). Этот метод совмещает преимущества двух стратегий:  
* Итеративность: система создается шаг за шагомм, с регулярной проверкой и обратной свзяью, что позволяет корректировать требования и обеспечивать качество.  
* Инкрементальность: каждое обновление (инкремент) добавляет в систему новые компоненты.  
Основные характеристики:  
* Разработка ведется сериями небольших выпусков  
* Промежуточные версии продукта представляют собой работающее ПО  
* Обратная связь от пользователей и тестировщиков активно используется на каждом этапе  
* Подходит для проектов, где трубования могут изменяться в процессе работы  
Преимущества:  
* Повышенная гибкость  
* Более быстрая поставка рабочего ПО  
* Раннее выявление ошибок  
* Постоянное улучшение дизайна и архитектуры  
Недостатки:  
* Риск архитектурных проблем  
* Требуется вовлеченный заказчик  
* Нагрузка на тестирование  
Этот подход лежит в основе гибких методологий


## 57. Эволюционная модель. Инкрементальная разработка  
Эволюционная модель разработки ПО предполагает постепенное создание системы через серию инкрементов, каждый и которых улучшает или расширяет существующую функциональность. Сначала создается MVP, а затем итеративно улучшается. Эта модель адаптивна к изменениям требований.  
Характеристики:  
* Проект реализуется поэтапно, через создлаваемые версии (инкременты)  
* Каждый инкремент- работающий продукт, обладающий все большей функциональностью  
* Основной акцент- на адаптацию к изменяющимся требованиям  
Преимущества:  
* Быстрая доставка основных функций  
* Удобная при разработке систем, требования к котороым неполные или меняются  
* Возможность раннего получения обратной связи от заказчика  
* Подходит для гибких методологий.  
Недостатки:  
* Затрудненное документирование  
* Риски вечного улучшения  
* Может быть дорого из-за постоянных доработок


## 58. IID как альтернатива модели водопада  
Итеративная инкрементальаня разработка рассматривается как гибкая альтернатива водопадной модели, особенно в условиях изменяющихся требований и высокой неопределенности.  
Отличия от водопадной модели:  
| Водопадная модель                 | IID                                    |  
| --------------------------------- | -------------------------------------- |  
| Последовательные фазы             | Повторяющиеся циклы (итерации)         |  
| Требования фиксируются заранее    | Требования могут уточняться в процессе |  
| Проверка и тестирование - в конце | Проверка - на каждом этапе             |  
| Малый отклик на изменения         | Гибкая адаптация к изменениям          |  
* В водопаде изменения трудны и дорогостоящи из-за строгой ступенчатой модели разработки, а IID легко адаптируется к изменениям в требованиях  
* В водопаде разработка идет строго поэтапно, а в IID маленькимим итерациями  
* Водопадная модель нацелена на получение сразу готового продукта, а IID развивает его постепенно  
* В водопадной модели серьезное внимание уделяется документированию программы, а в IID- скорости разработки и адаптации  
Исходя из этого, можно сделать вывод, что водопадная модель больше подходит для разработки систем с заранее известными и четко определенными требованиями, критически требовательными к точности работы ПО, а IID в тех случаях, когда важнее быстрый результат и гибкость.


## 59. Технология разработки высоконадженого программного обеспечения  
Разработка высоконадежного ПО ориентирована на создание систем, которые должын работать корректно при любых обстоятельствах, поскольку сбои могут привести к серьезным последствиям: финансовым потерям, угрозе жизни, катастрофам.  
Примеры таких систем:  
* Авицаионная ик осмическая техника  
* Медицинские устройства  
* Ядерные установки  
* Военные и оборонные системы  
Основные особенности технологии:  
1. Формальные методы- программное поведение доказывается математически  
2. Формализованные требования- все четко описано в документации и поддается проверкке  
3. Стандарты- работа строго по международным правилам  
4. Жесткий контроль изменения- любое изменение требует пересмотра всего  
5. Минимализм и отказоустойчивость- ничего лишнего, все дублируется на случай сбоев  
6. Качество код- простой, предсказуемый, проверяемый автоматически  
Недостатки:  
* очень высокая стоимость и длительность разработки  
* Меньшая гибкость- изменения в требованиях критичны  
* Ограничения в использовании современных технологий из-за сложности верификации


## 60. Водопадная (каскадная) модель жизненного цикла  
Это последоватльная модель разработки ПО, в которой каждый этап выполняется один за другим, строго по порядку:  
требования -> проектирование -> реализация -> тестирование -> внедрение -> сопровождение  
Особенности:  
* Переход к следующему этапу только после заврешения предыдущего  
* Все требовангия фиксируются заранее  
* Обратного хода практически нет (или он очень дорог)  
* Хорошо подходит для четко определенных проектов  
Минусы:  
* Плохо адаптируется к изменющимся требованиям  
* Ошибки на ранних этапах могут выявиться слишком поздно  
* Пользователь видит рузльтат только в конце проекта


## 61. V-образная модель (разработка через тестиорвание)  
Это расширение водопажной моднли, где каждому этапу разработки соответствует этап тестирования, расположенный напротив него- вместе они образуют V-образную диагрмму.  
Особенности:  
* Этапы идут последовательно: анализ -> проектирование -> кодирование -> тестирование  
* Тестирование планируется заранее, параллельно с проектированием  
* Упор на раннюю проверку требований и архитектуры  
* Отлично подходит для критичных к качеству систем  
Минусы:  
* Также плоххо приспособлена к изменениям на поздних этапах  
* Требует большого объема документации и тестовых спецификаций


## 62. Экстремальное программирование  
Это гибкая метдология разработка, основанная на философии agile и ориентированная на быструю поставку качественного ПО через частые релизы, тесную работу с заказчиком и постоянное улучшение кода.  
Ключевые практики:  
* Парное программирование  
* TDD- сначала тесты, потом под них код  
* Частые релизы  
* Рефакторинг- постоянная переработка кода без изменения поведения  
* Простота- реализуется только то, что нужно сейчас  
* Обратная связь от заказчика- он всегда на связи с командой  
Минусы:  
* Требует высокой дисциплины и вовлеченности  
* Не всегда подходит для больших распределенных команды или жестко регламентированных проектов


## 63. Гибкое моделировние  
Это подход к моделированию в разработке ПО, основанный на принципах Agile- делать только нужные модели, вовремя и с минимальными затратами без лизлишней формальности.  
Основные идеи:  
* Модели создаются по мере необходимости  
* Простота и понятность важнее полноты  
* Совместная работа- модели обсуждаются и создаются всей командой  
* Модели- не цель, а средство: они помогают понять, что и как реализовать  
Можелируем ровно столько, сколько нужно для эффективной разработки.  
Под моделями подразуемваются визуальные или текстовые описания того, как система должна работать.


## 64. Основные концепции и цели Agile Modeling  
Agile Modeling- это подход к моделированию, корторый следует принципа Agile-разработки: быстро, просто и по делу.  
Основные концепции:  
* Моделируй столько, сколько нужно, не больше  
* Каждая модель должна иметь четкую цель  
* Модели легко изменяются вместе с требованиями  
* Не ограничивайся одним типом модели, используй те, что полезны  
* Важнее, что показывает модель, а не как она оформлена  
Цели:  
* Ускорить понимание и проектирование системы  
* Снизить затраты на документацию  
* Упростить совместную раюоту в команде  
* Поддерживать гибкость в условиях меняющихся требований


## 65. Agile-манифест разработки ПО  
Agile-манифест- основополагающий документ, сформулировавший ценности и принципы гибкой разработки.  
4 Главыне ценности:  
1. Люди и взаимодействие важнее процессов и инструментов  
2. Работающий рподукт важнее исчерпывающей документации  
3. Сотруднечество с заказчиком важнее согласования условий контракта  
4. Готовность к изменениям важнее следования первоначальному плану


## 66. Принципы Agil Modeling  
Agile Modeling опирается на набор практических принципов, которые помогают моделировать эффективно и гибко.  
Основные принципы:  
1. Работающее ПО важнее подробных моделей  
2. Создавай модели итеративно - лучше частично и быстро, чем долго и идеально  
3. Сотрничай над моделями - обсуждение важнее одиночного рисования схем  
4. Создавай простые модели - чем проще, тем понятнее и полезнее  
5. Используй модели как средство коммуникации - не для отчета, а для понимания  
6. Моделируй по мере необходимости - не заренее, а когда действительно нужно  
7. Придерживайся обратной связи - уточняй модели по ходу, не бойся менять


## 67. SCRUM  
SCRUM- это популярный фреймворк управления проектами, построенная на спринтах, постоянной обратной связи и самоорганизующихся командах.  
Основные элементы:  
* Спринт- фиксированный цикл (обычно 1-4 недели), в котором создает работающий инкремент продукта  
* Producr Backlog- список всех задач и тртебований от заказчика  
* Sprint Backlog- задачи, отобранные для выполнения в текушем српинте  
* Scrum master- помогает комаде работать по scrum, устраняет препятствия  
* Product owner- представитель заказчика, приоритезирует требования  
* Daily Scrum- короткие ежедневные собрания команжы  
Цикл работы (спринт):  
1. Планирование что и как делать в спринте  
2. Разработка поставленных во время планирования stories  
3. Daily Scrum- все говорят кто что делал, что будет делать, какие проблемы возникают  
4. Sprint Review- показ заказчику готового инкремента  
5. Sprint Reprospective- обсуждение, что было сделано хорошо в текущем српинте, а что можно было улучшить


## 68. Жизненный цикл спринта  
1. Планирование спринта (Sprint Planning):  
Команда выбирает, какие задачи из Product Backlog попадут в текущий спринт и ставит себе цель спринта.  
2. Формирование Sprint Backlog:  
Определяются конкретные задачи, которые будут выполнены, и разбиваются на подзадачи.  
3. Выполнение задач (разработка):  
Команда работает над задачами. Каждый день проходит Daily Scrum - короткая синхронизация (кто что сделал, что будет делать, какие есть блокеры).  
4. Завершение спринта:  
Появляется инкремент продукта - работающая, протестированная часть системы.  
5. Обзор спринта (Sprint Review):  
Команда показывает результат заинтересованным сторонам, получает обратную связь.  
6. Ретроспектива (Sprint Retrospective):  
Внутренняя встреча команды - обсуждают, что было хорошо, что можно улучшить, какие действия предпринять в следующем спринте.


## 69. Канбан  
Канбан- метод управления задачами, основанный на визуализации потока работы и постепенном, непрерыввном улучшении процесса без жестких итераций.  
Ключевые элементы:  
1. Доска Канбан- визуально предствление всех задач, разбитое на стадии: To Do, In Progress, Done  
2. Карточки задач- каждая задача отображается в виже карточки, которую перемещают по доска по мере выполнения  
3. Ограничение WIP (Work In Progress)- ограничивается число задач в каждой колонке, чтобы избежать перегрузки команды  
4. Непрерываня доставка- задачи не копятся до спринта, а выполняются и выпускаются по готовности  
Преимущества:  
* Максимальная гибкость- можно менять приоритеты на лету  
* Отлично видно узкие места в процессе  
* Подходит как для разработки, так и для операционных задач  
Недостатки:  
* Нет четких временных рамок  
* Требует дисциплины и зрелости команды


## 70. Разница между Канбан и SCRUM  
| Характеристика          | SCRUM                                         | Kanban                                           |  
| ----------------------- | --------------------------------------------- | ------------------------------------------------ |  
| **Подход**              | Итерационный (спринты)                        | Поток задач (непрерывный)                        |  
| **Временные рамки**     | Фиксированные спринты (1-4 недели)            | Нет итераций, задачи идут одна за другой         |  
| **Роли**                | Есть чёткие роли: Scrum Master, Product Owner | Нет обязательных ролей                           |  
| **Планирование**        | Sprint Planning перед каждым спринтом         | Планирование по мере поступления задач           |  
| **Измерение прогресса** | Velocity (скорость команды по спринтам)       | Lead Time, Cycle Time (время прохождения задачи) |  
| **Ограничение задач**   | Количество задач на спринт                    | WIP - ограничение задач в каждой колонке         |  
| **Фокус**               | Поставлять инкременты продукта регулярно      | Оптимизировать поток и устранить узкие места     |


## 71. Практики Agile Modeling  
1. Создание моделей по необходимости - моделируй только то, что помогает прямо сейчас.  
2. Быстрая, итеративная работа с моделями - набросай, обсуди, уточни, не зацикливайся на идеальности.  
3. Использование простых инструментов - доска, стикеры, бумага - подойдут лучше, чем тяжёлый софт.  
4. Совместное моделирование - команда вместе создаёт и обсуждает модели (не в одиночку, не сверху вниз).  
5. Непрерывное улучшение моделей - уточняй и обновляй по ходу работы, не считай их "раз и навсегда".  
6. Сравнение альтернатив - перед принятием решений рассматривай несколько вариантов.


## 72. Быстрая разработка приложений  
RAD (Rapid Application Development)- подход к созданию ПО, ориентированный на максимально быстрое получение продукта с помощью прототипирования, активного участия заказчика и повторных итераций.  
Отличительные практики RAD:  
1. Прототипирование как основной способ общения  
Вместо длинных требований- рабочий прототип, котоырй заказчик может увидеть и потрогать.  
2. Итеративные ицклы с быстрым откликом  
Приложение создает поэтапно, каждый цикл- это улучшенный вариант предыдущего. Обратная связь от заказчика немедленно влияет на продукт.  
3. Минимальное планирование и документация  
Упор делается не на предварительное проектирование, а на быстрое вополщение идей в код, особенно с опомщью готовых компонент, генераторов, визуальных средств.  
4. Использование визуальных средств разработки  
5. Сборка из готовых компонентов  
6. Интенсивное взаимодействие с заказчиком  
Заказчик ежедневно комментирует, проверяет, направляет.  
7. Фокус на скорости и удобстве конечного пользователя  
Техническое соверщенство вторично- главное, чтобы продукт был удобен, полезен и готов как можно скорее.  
Главный подход RAD - "сначала сделай и покажи, потом доработай", а не "долго планируй, потом разрабатывай".


## 73. Преимущества и условаия применения Rapid Application Development  
Преимущества RAD:  
1. Высокая скорость разработки  
Продукт создает в кратчайшие сроки благодаря проттотипированию, повторному использованию. компонентов и визуальной разработке.  
2. Быстрая обратная связь  
Заказчик видит результат почти срзазу и может корректировать требования без долгих согласований.  
3. Гибкость в изменении требований  
RAD легко адаптируется под меняющиеся ожидания и цели проекта  
4. Снижение риска "не того продукта"  
Поскольку заказчик участвует на всех этапах, итоговое приложение почти всегда точно соответствует его ожиданиям.  
5. Удобство для небольших команд  
Методжика не трубует строгих ролей, ритуалов, спринтов- все можно просто быстро обсуждать и делать.  
Условия, при которых RAD работает эффективно:  
1. Наличие активного, доступного заказчика  
Он должен быть всегда вовлечен в процесс  
2. Проект небольшого или среднего размера  
RAD плохо масштабируется на крупные системы с большим числом участников и зависимостей  
3. Команда с широкими навыками  
4. Не критичная к качеству архитектура  
RAD подходит, когда нужна скорость, а не строгость  
5. Использование средств быстрогоо прототипирования  
RAD эффективен, когда можно применять drag-and-drop, low-code платформы, генераторы шаблонов  
Если заказчик рядом, сроки жмут, а важна проверка идеи - RAD даёт результат быстрее всех. Но в больших, сложных, критичных проектах - лучше Agile или строгие модели.
